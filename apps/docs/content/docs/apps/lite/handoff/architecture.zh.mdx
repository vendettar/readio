---
title: Core Architecture
---

## 1. 目录结构

```
src/
├── routes/              # TanStack Router 路由文件
│   ├── __root.tsx       # 根布局（AppShell、GlobalAudioController、Toast）
│   ├── index.tsx        # 主页/播放器（字幕阅读）
│   ├── explore.tsx      # 发现播客
│   ├── subscriptions.tsx # 订阅列表
│   ├── favorites.tsx    # 收藏节目
│   ├── history.tsx      # 播放历史
│   ├── files.tsx        # Files 路由布局（Outlet）
│   └── files/           # Files 子路由
│       ├── index.tsx    # Files 列表/文件夹网格
│       └── folder/
│           └── $folderId.tsx # Folder view
├── routeComponents/     # 路由页面组件（路由级 lazy 加载）
│   ├── ExplorePage.tsx
│   ├── SearchPage.tsx
│   ├── FavoritesPage.tsx
│   ├── HistoryPage.tsx
│   ├── SubscriptionsPage.tsx
│   ├── SettingsPage.tsx
│   ├── podcast/
│   │   ├── PodcastShowPage.tsx
│   │   ├── PodcastEpisodesPage.tsx
│   │   └── PodcastEpisodeDetailPage.tsx
│   └── files/
│       ├── FilesIndexPage.tsx
│       └── FilesFolderPage.tsx
├── components/
│   ├── AppShell/        # App Shell 组件
│   ├── GlobalSearch/    # 全局搜索组件 (Input, Overlay, StatusBadge)
│   ├── Transcript/      # 字幕相关组件
│   ├── Selection/       # 选词/查词组件
│   ├── FollowButton/    # 跟随按钮
│   ├── ZoomControl/     # 缩放控制
│   ├── PlayerControls/  # 播放器控件
│   ├── interactive/     # Custom interaction primitives (InteractiveTitle, InteractiveArtwork)
│   ├── Explore/         # Explore page business components (Carousels, Grid)
│   └── Toast/           # Toast 通知
├── hooks/               # 自定义 Hooks
│   ├── useLocalFilesData.ts      # 本地文件数据加载
│   ├── useLocalFileProcessing.ts # 文件处理逻辑（处理器）
│   ├── useLocalFileDragDrop.ts   # 拖拽逻辑
│   ├── useLocalFolderManagement.ts # 文件夹管理
│   ├── useEpisodeResolution.ts   # 单集解析与恢复逻辑
│   ├── useGlobalSearch.ts        # 全局搜索聚合器
│   ├── useLocalSearch.ts         # 本地数据库/Store 搜索
│   └── useDiscoverySearch.ts     # 远程 Provider 搜索
├── libs/                # 工具库
│   ├── dexieDb.ts       # Dexie 数据库封装
│   ├── exploreApi.ts    # 播客搜索/RSS 解析 API
│   ├── translations.ts  # i18n 翻译
│   └── recommended/
│       └── cache.ts     # 推荐缓存（前缀：readioExplore*）
├── store/               # Zustand stores
│   ├── playerStore.ts   # 播放器状态
│   ├── searchStore.ts   # 搜索状态管理
│   ├── exploreStore.ts  # Explore 状态
│   └── immersionStore.ts # 沉浸模式状态
├── router.tsx           # Router 实例
└── routeTree.gen.ts     # 自动生成的路由树
```

## 2. App Shell 架构

应用采用 App Shell 模式，由 `src/components/AppShell/` 组件提供：

### 布局结构

```
│ - Search (Global)  │  Main Content (flex-1)          │
│                  │                                 │
│ - Discover        │  <Outlet /> (路由内容)          │
│   - Explore       │                                 │
│ - Library        │                                 │
│   - Subscriptions│                                 │
│   - Favorites    │                                 │
│   - History      │                                 │
│   - Files        │                                 │
│ - Settings       │                                 │
├──────────────────┴─────────────────────────────────┤
│               MiniPlayer (bottom, fixed)           │
└────────────────────────────────────────────────────┘
```

### 关键组件

|组件 | 文件 | 职责 |
|------|------|------|
| AppShell | `src/components/AppShell/AppShell.tsx` | 协调布局，根据 immersion 状态决定显示内容 |
| Sidebar | `src/components/AppShell/Sidebar.tsx` | 左侧导航栏（集成了 GlobalSearchInput 和 SearchOverlay） |
| GlobalSearchInput | `src/components/GlobalSearch/GlobalSearchInput.tsx` | 侧边栏顶部的全局搜索框，支持 ⌘K 快捷键 |
| SearchOverlay | `src/components/GlobalSearch/SearchOverlay.tsx` | 搜索预览弹层（一阶段结果预览） |
| MiniPlayer | `src/components/AppShell/MiniPlayer.tsx` | 底部播控（高度 73px），采用业界领先的胶囊设计：封面图外置、拖拽进度条、动态音量等级图标 |
| FullPlayer | `src/components/AppShell/FullPlayer.tsx` | 全屏沉浸阅读模式 |
| BootLoader | `src/components/AppShell/BootLoader.tsx` | 全屏启动加载器，在应用数据水合期间显示 |

### Immersion Mode（沉浸模式）

- **状态管理**：`src/store/immersionStore.ts`（Zustand）
- **进入方式**：点击 MiniPlayer 区域或展开按钮
- **退出方式**：点击 FullPlayer 右上角 Minimize 按钮
- **行为**：
  - 进入时：隐藏 Sidebar，全屏显示 FullPlayer
  - 退出时：恢复正常布局
  - 播放不中断：`<audio>` 元素由 `GlobalAudioController` 持久挂载在 `__root.tsx` 内

### 性能隔离：GlobalAudioController

为避免音频 `timeupdate` 导致根布局高频重渲染，音频处理被隔离到 `GlobalAudioController.tsx`：

| 组件 | 文件 | 职责 |
|------|------|------|
| GlobalAudioController | `src/components/AppShell/GlobalAudioController.tsx` | 处理 `<audio>` 生命周期、事件监听（timeupdate、play/pause、seek）、音量/速率同步。使用精确 Zustand 选择器与 `getState()` 调用。 |

该设计确保 `RootLayout` 在路由切换之外保持静态，播放过程中仅控制器与进度条组件更新。

### 空间感：共享元素转换 (Shared Element Transitions)

为了在使用 `layoutId` 进行视觉衔接的同时保证架构的清晰性，系统遵循以下规则（见决策 D057）：

- **唯一性规则**：同一时间在渲染树中，具有相同 `layoutId` 的元素必须是物理上同一个逻辑对象的不同呈现。
- **视图兼容性**：MiniPlayer 与 FullPlayer 的封面图共享 `artwork-${id}-player` ID，确保从底部胶囊到全屏封面的平滑“morph”转换。
- **条件渲染**：在 `FullPlayer` 等包含多屏幕适配（Desktop/Mobile）的组件中，必须通过 `isDesktop` 等状态确保只有当前可见的封面占位符持有 `layoutId`，以防止 Framer Motion 布局计算冲突。

---

## 2. 路由（TanStack Router + File-Based Routing）

使用 TanStack Router 实现路由，通过 Vite 插件自动生成路由树。

### 路由结构

| 路径 | 文件 | 说明 |
|------|------|------|
| `/` | `src/routes/index.tsx` | 主播放器页面（字幕阅读） |
| `/search` | `src/routes/search.tsx` | 全局搜索结果页（接受 `?q=` 参数） |
| `/explore` | `src/routes/explore.tsx` | 发现播客（搜索） |
| `/podcast/:id` | `src/routes/podcast/$id.tsx` | 播客详情页（节目列表） |
| `/podcast/:id/episode/:episodeId` | `src/routes/podcast/$id/episode/$episodeId.tsx` | 单集详情页 |
| `/subscriptions` | `src/routes/subscriptions.tsx` | 订阅列表 |
| `/favorites` | `src/routes/favorites.tsx` | 收藏节目 |
| `/history` | `src/routes/history.tsx` | 播放历史 |
| `/files` | `src/routes/files.tsx` | Files 页面（音频、字幕管理，支持文件夹、拖放） |
| `/settings` | `src/routes/settings.tsx` | 设置页面 |

### 页面导航约定

- 页面内不提供“返回上一页/返回上级”按钮；用户通过 Sidebar 导航或浏览器原生返回进行页面切换。

### 关键设计

- **播放器常驻**：`<audio>` 元素在 `GlobalAudioController` 中挂载（由 `__root.tsx` 常驻），路由切换不中断播放
- **路由生成**：`src/routeTree.gen.ts` 由 Vite 插件自动生成
- **路由级按需加载**：`/explore`、`/search`、播客详情/单集/历史/收藏/Files 等页面使用 `lazyRouteComponent` 拆分，减少首包体积
- **重模块按需加载**：主播放页的 `TranscriptView` 与沉浸模式 `FullPlayer` 使用 `React.lazy` 延迟加载
- **全局样式**：CSS 在 `main.tsx` 入口引入，确保所有路由可用
- **播放控制**：进度条拖动通过 `onSeek` → `store.seekTo` → `store.pendingSeek` → `__root.tsx` 的 audio element，避免直接 DOM 操作
- **规范重定向**：强制在 `beforeLoad` 或 `loader` 钩子中执行 `throw redirect()`，而非在渲染过程中使用 `useEffect` 或 `<Navigate />` 组件，以防止布局闪烁并确保数据就绪。

---

## 3. 架构加固 (Architecture Hardening)

### 代码分割

- **Vendor 分块**：`vite.config.ts` 使用 `manualChunks` 将大型依赖拆分

### 错误隔离

| 边界 | 覆盖范围 | 回退 UI |
|------|----------|---------|
| `RootErrorBoundary` | 整个应用 | 全屏错误页面 + 刷新按钮 |
| TranscriptView ErrorBoundary | 字幕视图 | 友好错误提示 + 复制诊断信息按钮 |

### 播放不中断

`<audio>` 元素挂载在 `GlobalAudioController`（位于 `__root.tsx` 内），路由切换不影响播放

### 标签页同步（单例播放）

- 使用 `BroadcastChannel('readio_sync')`，消息包含 `senderId` 与 `timestamp`。
- 忽略当前标签发送的消息，忽略超过 2 秒的旧消息。
- 当 `BroadcastChannel` 不可用时，使用 `localStorage` 的 `storage` 事件作为回退。

### 持久化与恢复（播放器生命周期）

系统采用健壮的、由 Store 驱动的生命周期来管理播放进度和状态：

- **状态机**：`playerStore` 维护两个独立的状态字段：
  - `initializationStatus` (`idle | restoring | ready | failed`)：追踪应用启动和会话恢复。
  - `status` (`idle | loading | playing | paused | error`)：严格的播放生命周期管理，防止竞态条件。
- **单一数据源**：所有持久化操作集中在 `playerStore.ts` 中。`useSession` 和 `useFileHandler` 等 Hook 委托 Store Action 处理存储，不再直接操作数据库。
- **节流持久化**：进度更新采用节流机制（默认 5s）以减轻 IndexedDB 写入压力。`saveProgressNow` Action 确保在组件卸载或关键事件时立即保存。
- **时间戳完整性**：`lastPlayedAt` 时间戳仅在活跃播放期间（`isPlaying: true`）更新。这确保了后台恢复或仅 UI 的调整（暂停时跳转）不会影响 History/Files 中的时间排序（见决策 D056）。
- **原子化恢复**：`restoreSession` Action 封装了获取最后会话、恢复文件/URL 以及更新状态的完整逻辑，确保恢复过程的原子性。
- **分层校验**：文件校验与注入逻辑解耦。Lite 应用执行 MIME/扩展名校验，深层内容校验推迟到后端或 Native 层（见决策 D046）。
- **异步任务卫生 (Async Hygiene)**：所有异步任务都使用 `requestId` 或 `AbortSignal` 防止过期更新。显式追踪 `setTimeout` 和 `requestAnimationFrame` 并在组件卸载时取消，防止内存泄漏。
- **异步序列门控 (Sequence Gating)**：关键流程（如会话创建、词典查询）使用 Ref 门控防止同一异步操作的并行重入。


---

## 3a. 状态管理最佳实践 (Zustand)

### 原子选择器 (Atomic Selectors) - 性能关键

**务必使用原子选择器**来订阅单个 Store 字段。严禁解构整个 Store。

```tsx
// ❌ 反模式：订阅了 Store 的所有变更
const { field1, field2, field3, progress } = usePlayerStore()

// ✅ 最佳实践：订阅单个字段
const field1 = usePlayerStore((s) => s.field1)
const field2 = usePlayerStore((s) => s.field2)
const field3 = usePlayerStore((s) => s.field3)
const progress = usePlayerStore((s) => s.progress)
```

**原理说明**: 
- 解构赋值 `const { ... } = useStore()` 会让组件订阅 **Store 中的每一个字段**。
- 意味着 Store 中任何一个字段更新（甚至是组件未使用的字段），都会触发该组件重新渲染。
- 对于 `progress` 这种每秒更新多次的高频字段，这会导致严重的性能损耗。

**适用场景**:
- 渲染高频更新字段的组件（如 `progress`, `currentIndex`）。
- 渲染成本较高的组件（包含图片、复杂布局、手势、动画等）。
- 列表组件或媒体资产渲染组件。

### 示例：优化前后对比

**优化前（存在性能瓶颈）**:
```tsx
export function MiniPlayer() {
  const { progress, coverArtUrl, isPlaying } = usePlayerStore()
  // ❌ 只要 Store 发生任何变更，组件就会重新渲染
  // ❌ 会导致 progress 更新时封面图闪烁
}
```

**优化后（已隔离性能影响）**:
```tsx
export function MiniPlayer() {
  const progress = usePlayerStore((s) => s.progress)
  const coverArtUrl = usePlayerStore((s) => s.coverArtUrl)
  const isPlaying = usePlayerStore((s) => s.isPlaying)
  // ✅ 组件仅在这些特定字段变化时才重新渲染
  // ✅ 消除闪烁，最小化渲染开销
}
```

### Store 访问模式

**只读访问 (非响应式)**:
```tsx
// 用于异步函数或事件处理函数内部读取状态
const currentProgress = usePlayerStore.getState().progress
```

**订阅变更 (响应式)**:
```tsx
// 用于反应式 UI 更新
const progress = usePlayerStore((s) => s.progress)
```

**Actions (函数)**:
```tsx
// Action 函数不会改变，一次提取即可
const seekTo = usePlayerStore((s) => s.seekTo)
const togglePlayPause = usePlayerStore((s) => s.togglePlayPause)
```

### 性能验证方法

重构订阅模式后：
1. 使用 React DevTools Profiler 测量渲染计数。
2. 预期结果：播放 10 秒期间，组件渲染次数应从 100+ 次降低到 ~5-10 次。
3. 验证图片/封面图无视觉闪烁。
4. 确认所有交互逻辑正常。

---

## 计划中（待执行）

- **本地错误日志**：可下载诊断日志（指令 047）。
- **DB 访问防护**：禁止 UI 直接导入 DB（指令 057）。
- **原子写入防护**：事务化写入与启动修复（指令 067）。

---

## 4. 技术栈

| 类别 | 技术 |
|------|------|
| 框架 | React 19 + TypeScript + Vite |
| 路由 | TanStack Router (file-based) |
| 状态 | Zustand |
| 持久化 | Dexie (IndexedDB) |
| 网络缓存 | TanStack Query |
| 弹层/Tooltip | Radix UI |
| Toast | Sonner |
| 样式 | Tailwind CSS + shadcn/ui |
| 测试 | Vitest + Playwright |
| i18n | react-i18next（useTranslation） |
