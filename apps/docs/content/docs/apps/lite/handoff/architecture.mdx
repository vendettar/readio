---
title: Core Architecture
---

## 1. Directory Structure

```
src/
├── routes/              # TanStack Router route files
│   ├── __root.tsx       # Root layout (AppShell, GlobalAudioController, Toast)
│   ├── index.tsx        # Home/Player (Subtitle Reading)
│   ├── explore.tsx      # Discover Podcasts
│   ├── subscriptions.tsx # Subscriptions List
│   ├── favorites.tsx    # Favorite Episodes
│   ├── history.tsx      # Playback History
│   ├── files.tsx        # Files Route Layout (Outlet)
│   └── files/           # Files Sub-routes
│       ├── index.tsx    # Files List/Folder Grid
│       └── folder/
│           └── $folderId.tsx # Folder view
├── routeComponents/     # Route page components (Route-level lazy loading)
│   ├── ExplorePage.tsx
│   ├── SearchPage.tsx
│   ├── FavoritesPage.tsx
│   ├── HistoryPage.tsx
│   ├── SubscriptionsPage.tsx
│   ├── SettingsPage.tsx
│   ├── podcast/
│   │   ├── PodcastShowPage.tsx
│   │   ├── PodcastEpisodesPage.tsx
│   │   └── PodcastEpisodeDetailPage.tsx
│   └── files/
│       ├── FilesIndexPage.tsx
│       └── FilesFolderPage.tsx
├── components/
│   ├── AppShell/        # App Shell Components
│   ├── GlobalSearch/    # Global Search Components (Input, Overlay, StatusBadge)
│   ├── Transcript/      # Transcript Components
│   ├── Selection/       # Selection/Lookup Components
│   ├── FollowButton/    # Follow Button
│   ├── ZoomControl/     # Zoom Control
│   ├── PlayerControls/  # Player Controls
│   ├── interactive/     # Custom interaction primitives (InteractiveTitle, InteractiveArtwork)
│   ├── Explore/         # Explore page business components (Carousels, Grid)
│   └── Toast/           # Toast Notifications
├── hooks/               # Custom Hooks
│   ├── useLocalFilesData.ts      # Local files data loading
│   ├── useLocalFileProcessing.ts # File processing (handlers only)
│   ├── useLocalFileDragDrop.ts   # Drag & Drop logic
│   ├── useLocalFolderManagement.ts # Folder management
│   ├── useEpisodeResolution.ts   # Episode recovery logic
│   ├── useGlobalSearch.ts        # Global search aggregator
│   ├── useLocalSearch.ts         # Local DB/Store search
│   └── useDiscoverySearch.ts     # Remote provider search
├── libs/                # Utilities
│   ├── dexieDb.ts       # Dexie Database Wrapper
│   ├── exploreApi.ts    # Podcast Search/RSS Parse API
│   ├── translations.ts  # i18n Translations
│   └── recommended/
│       └── cache.ts     # Recommendation Cache (Prefix: readioExplore*)
├── store/               # Zustand stores
│   ├── playerStore.ts   # Player State
│   ├── searchStore.ts   # Search State Management
│   ├── exploreStore.ts  # Explore State
│   └── immersionStore.ts # Immersion Mode State
├── router.tsx           # Router Instance
└── routeTree.gen.ts     # Auto-generated Route Tree
```

## 2. App Shell Architecture

The application adopts the App Shell pattern, provided by `src/components/AppShell/` components:

### Layout Structure

```
│ - Search (Global)  │  Main Content (flex-1)          │
│                  │                                 │
│ - Discover        │  <Outlet /> (Route Content)     │
│   - Explore       │                                 │
│ - Library        │                                 │
│   - Subscriptions│                                 │
│   - Favorites    │                                 │
│   - History      │                                 │
│   - Files        │                                 │
│ - Settings       │                                 │
├──────────────────┴─────────────────────────────────┤
│               MiniPlayer (bottom, fixed)           │
└────────────────────────────────────────────────────┘
```

### Key Components

|Component | File | Responsibility |
|------|------|------|
| AppShell | `src/components/AppShell/AppShell.tsx` | Coordinates layout, determines content display based on immersion state |
| Sidebar | `src/components/AppShell/Sidebar.tsx` | Left navigation bar (integrates GlobalSearchInput and SearchOverlay) |
| GlobalSearchInput | `src/components/GlobalSearch/GlobalSearchInput.tsx` | Global search box at the top of the sidebar, supports ⌘K shortcut |
| SearchOverlay | `src/components/GlobalSearch/SearchOverlay.tsx` | Search preview overlay (Stage 1 result preview) |
| MiniPlayer | `src/components/AppShell/MiniPlayer.tsx` | Bottom playback controls (Height 73px), using industry-leading capsule design: external cover art, drag-and-drop progress bar, dynamic volume level icon |
| FullPlayer | `src/components/AppShell/FullPlayer.tsx` | Full-screen immersive reading mode |
| BootLoader | `src/components/AppShell/BootLoader.tsx` | Full-screen splash loader shown during app data hydration |

### Immersion Mode

- **State Management**: `src/store/immersionStore.ts` (Zustand)
- **Entry Method**: Click MiniPlayer area or Expand button
- **Exit Method**: Click Minimize button in top right of FullPlayer
- **Behavior**:
  - On Entry: Display FullPlayer as a full-screen overlay. The **Main Content and MiniPlayer remain mounted** in the tree (potentially hidden visually) to support shared element transitions (`layoutId`).
  - On Exit: Close FullPlayer overlay and restore focus to MiniPlayer.
  - Uninterrupted Playback: `<audio>` element persists in `GlobalAudioController` (always mounted in `__root.tsx`)

### Performance Isolation: GlobalAudioController

To prevent the entire application from re-rendering on every audio tick (timeupdate), all audio element handling is isolated in `GlobalAudioController.tsx`:

| Component | File | Responsibility |
|------|------|------|
| GlobalAudioController | `src/components/AppShell/GlobalAudioController.tsx` | Handles `<audio>` element lifecycle, event listeners (timeupdate, play/pause, seek), volume/rate sync. Uses atomic Zustand selectors and `getState()` for actions. |

GlobalAudioController also integrates Media Session via `useMediaSession`, exposing OS playback controls and metadata without introducing a new playback source.

This ensures `RootLayout` remains effectively static unless the route changes, while only `GlobalAudioController` and any progress-bar components re-render during playback.

### Background Performance (Page Visibility)

- `usePageVisibility` (`src/hooks/usePageVisibility.ts`) tracks `document.visibilitychange`.
- `GlobalAudioController` throttles `updateProgress` to **≤ 1/sec** when hidden, while continuing audio processing.
- `FullPlayer` pauses CSS and Framer Motion animations when hidden (no unmount).

### Spatial Presence: Shared Element Transitions

The application utilizes `layoutId` (Framer Motion) to maintain visual continuity when moving between global UI states (see Decision D057):

- **Uniqueness Rule**: Within the active render tree, a `layoutId` must uniquely identify a logical object's visual representation.
- **Context Compatibility**: The artwork for list items and the active player (Mini/Full) share the `artwork-${id}-player` ID to enable smooth "morphing."
- **Conditional Target**: In components with responsive layouts (like `FullPlayer`), the `layoutId` is applied conditionally based on the viewport (e.g., `isDesktop`) to ensure only one active node holds the ID at any time, avoiding layout engine collisions.
- **Scoping for Duplicate Content**: If the same logical object (e.g., a Podcast Show) appears multiple times on a single page (like in different sections of the Explore page), a unique prefix (e.g., `sectionId`) MUST be prepended to the `layoutId` to prevent collisions. Navigation to detail pages MUST pass this prefix via search parameters (`fromLayoutPrefix`) so the target page can match the specific originating element.

---

## 3. Routing (TanStack Router + File-Based Routing)

Uses TanStack Router for routing, with the route tree automatically generated by the Vite plugin.

### Route Structure

| Path | File | Description |
|------|------|------|
| `/` | `src/routes/index.tsx` | Main Player Page (Subtitle Reading) |
| `/search` | `src/routes/search.tsx` | Global Search Results Page (Accepts `?q=` param) |
| `/explore` | `src/routes/explore.tsx` | Discover Podcasts (Search) |
| `/podcast/:id` | `src/routes/podcast/$id.tsx` | Podcast Show Page (Episode List) |
| `/podcast/:id/episode/:episodeId` | `src/routes/podcast/$id/episode/$episodeId.tsx` | Episode Detail Page |
| `/subscriptions` | `src/routes/subscriptions.tsx` | Subscriptions List |
| `/favorites` | `src/routes/favorites.tsx` | Favorite Episodes |
| `/history` | `src/routes/history.tsx` | Playback History |
| `/files` | `src/routes/files.tsx` | Files Page (Audio/Subtitle management, Folder support, Drag & Drop) |
| `/settings` | `src/routes/settings.tsx` | Settings Page |

### Page Navigation Conventions

- Pages do not provide "Back to Previous/Up" buttons; users navigate via Sidebar or browser native back button.

### Key Designs

- **Persistent Player**: `<audio>` element and playback state mount in `__root.tsx`, playback is not interrupted by route changes
- **Route Generation**: `src/routeTree.gen.ts` is automatically generated by Vite plugin
- **Route-level Lazy Loading**: `/explore`, `/search`, Podcast Detail/Episode/History/Favorites/Files pages use `lazyRouteComponent` to split chunks, reducing initial bundle size
- **Heavy Module Lazy Loading**: `TranscriptView` in Main Player and `FullPlayer` in Immersion Mode use `React.lazy` for deferred loading
- **Global Styles**: CSS imported in `main.tsx` entry, ensuring availability across all routes
- **Playback Control**: Progress bar drag via `onSeek` → `store.seekTo` → `store.pendingSeek` → `__root.tsx` audio element, avoiding direct DOM manipulation
- **Proper Redirects**: Enforce `throw redirect()` inside `beforeLoad` or `loader` hooks rather than render-time `useEffect` or `<Navigate />` components to prevent layout thrashing and ensures data readiness.

---

## 4. Architecture Hardening

### Code Splitting

- **Vendor Chunks**: `vite.config.ts` uses `manualChunks` to split large dependencies

### Error Isolation

| Boundary | Scope | Fallback UI |
|------|----------|---------|
| `RootErrorBoundary` | Entire App | Full screen error page + Refresh button |
| TranscriptView ErrorBoundary | Transcript View | Friendly error message + Copy diagnostic info button |

### Uninterrupted Playback

`<audio>` element mounted in `GlobalAudioController` (inside `__root.tsx`), route switching does not affect playback.

### Tab Synchronization (Singleton Playback)

- Implemented via `useTabSync` in `src/hooks/useTabSync.ts` and mounted in `GlobalAudioController`.
- Use `BroadcastChannel('readio_sync')` with `senderId` and `timestamp` on play start.
- Ignore events from the current tab and any event older than 2 seconds.
- Pause only when the receiving tab is currently playing (`isPlaying === true`).
- Provide a `localStorage` `storage` event fallback when BroadcastChannel is unavailable.

### Persistence & Restoration (Player Lifecycle)

The system uses a robust, store-driven lifecycle for maintaining playback progress and state:

- **State Machine**: `playerStore` maintains two distinct status fields:
  - `initializationStatus` (`idle | restoring | ready | failed`): Tracks app boot and session hydration.
  - `status` (`idle | loading | playing | paused | error`): Strict playback lifecycle management to prevent race conditions.
- **Single Source of Truth**: All persistence operations are centralized in `playerStore.ts`. Hooks like `useSession` and `useFileHandler` delegate to store actions rather than writing to DB directly.
- **Throttled Persistence**: Progress updates are throttled (default 5s) to reduce IndexedDB write pressure. A `saveProgressNow` action ensures data is saved immediately on unmount or critical events.
- **Timestamp Integrity**: The `lastPlayedAt` timestamp is only updated during active playback (`isPlaying: true`). This ensures that background restoration or UI-only adjustments (seeking while paused) do not affect chronological sorting in History/Files (see Decision D056).
- **Atomic Restoration**: The `restoreSession` action encapsulates the entire logic of fetching the last session, restoring files/URLs, and updating state in a single atomic operation.
- **Validation Layers**: File validation is decoupled from ingestion. The `lite` app performs MIME/extension checks, while deep content validation is deferred to backend/native layers (see Decision D046).
- **Async Task Hygiene**: All async tasks are gated against stale updates using `requestId` or `AbortSignal`. Timers and `requestAnimationFrame` calls are explicitly tracked and cancelled on unmount to prevent memory leaks and state updates on unmounted components.
- **Async Sequence Gating**: Critical flows (e.g., session creation, dictionary lookup) use ref-based guards to prevent parallel re-entrancy of the same async operation.

### Boot-Time Maintenance (Data Retention) [Implemented]

To maintain performance and prevent unbounded storage growth of metadata, the app executes a non-blocking maintenance task during the boot sequence (see `useAppInitialization`).

- **Task**: `prunePlaybackHistory` (`src/lib/retention.ts`)
- **Policy**: Keep the most recent **1000** sessions OR **last 6 months**, whichever is more restrictive.
- **Implementation**: Uses a batch-delete strategy (e.g., chunks of 100) with small delays between batches to ensure the main thread remains responsive for user interaction during initial load.

### Centralized Resource Management (ObjectURLs)

The application follows strict rules for managing transient browser resources (Blob URLs) to prevent memory leaks in a single-page environment:

- **Audio Resource Authority**: The `playerStore` is the **only** permitted creator and owner of Audio ObjectURLs. It maintains an `activeBlobUrls` array and ensures that before a new audio source is loaded or restored, all previously tracked URLs are explicitly revoked via `URL.revokeObjectURL()`.
- **Image Resource Delegation**: Image ObjectURLs are managed at the component level using the `useImageObjectUrl` hook. This hook encapsulates the `create` and `revoke` lifecycle, tying the lifetime of the URL to the mounting of the component (e.g., `TrackCard`, `InteractiveArtwork`) or the presence of the source Blob.
- **Strict Separation**: Components never create audio URLs. Instead, they pass raw Blobs from IndexedDB to store actions like `loadAudioBlob()`.

### Supportability: Diagnostic Logging [Implemented]

To facilitate remote troubleshooting of PWA "black boxes", the app maintains a lightweight diagnostic subsystem:
- **Authority**: `src/lib/logger.ts` encapsulates all logging logic.
- **Buffer**: A 100-entry in-memory FIFO buffer captures Errors, Warnings, and essential Info.
- **Global Collection**: `main.tsx` registers window-level listeners for unhandled errors and promise rejections, routing them to the internal buffer.
- **Privacy Enforcement**: A strict `redact()` function filters all incoming strings, replacing local file paths, usernames, and emails with generic tags before they reach the buffer.
- **Support Flow**: Users can export this buffer as a `.json` file from the Settings page to share with developers.

---

## 4a. State Management Best Practices (Zustand)

### Atomic Selectors (Critical for Performance)

**Always use atomic selectors** to subscribe to individual store fields. Never destructure the entire store.

```tsx
// ❌ ANTI-PATTERN: Subscribes to ALL store changes
const { field1, field2, field3, progress } = usePlayerStore()

// ✅ BEST PRACTICE: Subscribe to individual fields
const field1 = usePlayerStore((s) => s.field1)
const field2 = usePlayerStore((s) => s.field2)
const field3 = usePlayerStore((s) => s.field3)
const progress = usePlayerStore((s) => s.progress)
```

**Rationale**: 
- Destructuring `const { ... } = useStore()` subscribes to **every field in the store**
- Components will re-render on **any** store update, not just changes to destructured fields
- This causes severe performance issues with high-frequency fields like `progress` (updates multiple times per second)

**Critical for**:
- Components rendering high-frequency fields (`progress`, `currentIndex`)
- Components with expensive rendering (images, complex layouts, gestures, animations)
- List components or components rendering media assets

### Example: Before vs After

**Before (Performance Issue)**:
```tsx
export function MiniPlayer() {
  const { progress, coverArtUrl, isPlaying } = usePlayerStore()
  // ❌ Component re-renders every time ANY store field changes
  // ❌ Causes image flickering when progress updates
}
```

**After (Optimized)**:
```tsx
export function MiniPlayer() {
  const progress = usePlayerStore((s) => s.progress)
  const coverArtUrl = usePlayerStore((s) => s.coverArtUrl)
  const isPlaying = usePlayerStore((s) => s.isPlaying)
  // ✅ Component only re-renders when individual fields change
  // ✅ No flickering, minimal re-renders
}
```

### Store Access Patterns

**Read-Only Access**:
```tsx
// For reading state in async functions or event handlers
const currentProgress = usePlayerStore.getState().progress
```

**Subscribe to Changes**:
```tsx
// For reactive UI updates
const progress = usePlayerStore((s) => s.progress)
```

**Actions (Functions)**:
```tsx
// Actions don't change, safe to extract once
const seekTo = usePlayerStore((s) => s.seekTo)
const togglePlayPause = usePlayerStore((s) => s.togglePlayPause)
```

### Performance Verification

After refactoring store subscriptions:
1. Use React DevTools Profiler to measure render counts
2. Expected: ~5-10 renders during 10s of playback (down from 100+)
3. Verify no visual flickering in images/artwork
4. Confirm all functionality works correctly

---

## Planned (Pending Execution)

- **DB Access Guard**: Prevent direct DB imports from UI (Instruction 057).
- **Atomic Write Safeguards**: Boot-time repair and transactional writes (Instruction 067).

---

## 5. Technology Stack

| Category | Tech |
|------|------|
| Framework | React 19 + TypeScript + Vite |
| Routing | TanStack Router (file-based) |
| State | Zustand |
| Persistence | Dexie (IndexedDB) |
| Network Cache | TanStack Query |
| Overlay/Tooltip | Radix UI |
| Toast | Sonner |
| Styling | Tailwind CSS + shadcn/ui |
| Testing | Vitest + Playwright |
| i18n | react-i18next (useTranslation) |
