---
title: Core Architecture
---

## 1. Directory Structure

```
src/
├── routes/              # TanStack Router route files
│   ├── __root.tsx       # Root layout (AppShell, GlobalAudioController, Toast)
│   ├── index.tsx        # Home/Player (Subtitle Reading)
│   ├── explore.tsx      # Discover Podcasts
│   ├── subscriptions.tsx # Subscriptions List
│   ├── favorites.tsx    # Favorite Episodes
│   ├── history.tsx      # Playback History
│   ├── files.tsx        # Files Route Layout (Outlet)
│   └── files/           # Files Sub-routes
│       ├── index.tsx    # Files List/Folder Grid
│       └── folder/
│           └── $folderId.tsx # Folder view
├── routeComponents/     # Route page components (Route-level lazy loading)
│   ├── ExplorePage.tsx
│   ├── SearchPage.tsx
│   ├── FavoritesPage.tsx
│   ├── HistoryPage.tsx
│   ├── SubscriptionsPage.tsx
│   ├── SettingsPage.tsx
│   ├── podcast/
│   │   ├── PodcastShowPage.tsx
│   │   ├── PodcastEpisodesPage.tsx
│   │   └── PodcastEpisodeDetailPage.tsx
│   └── files/
│       ├── FilesIndexPage.tsx
│       └── FilesFolderPage.tsx
├── components/
│   ├── AppShell/        # App Shell Components
│   ├── GlobalSearch/    # Global Search Components (Input, Overlay, StatusBadge)
│   ├── Transcript/      # Transcript Components
│   ├── Selection/       # Selection/Lookup Components
│   ├── FollowButton/    # Follow Button
│   ├── ZoomControl/     # Zoom Control
│   ├── PlayerControls/  # Player Controls
│   ├── interactive/     # Custom interaction primitives (InteractiveTitle, InteractiveArtwork)
│   ├── Explore/         # Explore page business components (Carousels, Grid)
│   └── Toast/           # Toast Notifications
├── hooks/               # Custom Hooks
│   ├── useLocalFilesData.ts      # Local files data loading
│   ├── useLocalFileProcessing.ts # File processing (handlers only)
│   ├── useLocalFileDragDrop.ts   # Drag & Drop logic
│   ├── useLocalFolderManagement.ts # Folder management
│   ├── useEpisodeResolution.ts   # Episode recovery logic
│   ├── useGlobalSearch.ts        # Global search aggregator
│   ├── useLocalSearch.ts         # Local DB/Store search
│   └── useDiscoverySearch.ts     # Remote provider search
├── libs/                # Utilities
│   ├── dexieDb.ts       # Dexie Database Wrapper
│   ├── exploreApi.ts    # Podcast Search/RSS Parse API
│   ├── translations.ts  # i18n Translations
│   └── recommended/
│       └── cache.ts     # Recommendation Cache (Prefix: readioExplore*)
├── store/               # Zustand stores
│   ├── playerStore.ts   # Player State
│   ├── searchStore.ts   # Search State Management
│   ├── exploreStore.ts  # Explore State
│   └── immersionStore.ts # Immersion Mode State
├── router.tsx           # Router Instance
└── routeTree.gen.ts     # Auto-generated Route Tree
```

## 2. App Shell Architecture

The application adopts the App Shell pattern, provided by `src/components/AppShell/` components:

### Layout Structure

```
│ - Search (Global)  │  Main Content (flex-1)          │
│                  │                                 │
│ - Discover        │  <Outlet /> (Route Content)     │
│   - Explore       │                                 │
│ - Library        │                                 │
│   - Subscriptions│                                 │
│   - Favorites    │                                 │
│   - History      │                                 │
│   - Files        │                                 │
│ - Settings       │                                 │
├──────────────────┴─────────────────────────────────┤
│               MiniPlayer (bottom, fixed)           │
└────────────────────────────────────────────────────┘
```

### Key Components

|Component | File | Responsibility |
|------|------|------|
| AppShell | `src/components/AppShell/AppShell.tsx` | Coordinates layout, determines content display based on immersion state |
| Sidebar | `src/components/AppShell/Sidebar.tsx` | Left navigation bar (integrates GlobalSearchInput and SearchOverlay) |
| GlobalSearchInput | `src/components/GlobalSearch/GlobalSearchInput.tsx` | Global search box at the top of the sidebar, supports ⌘K shortcut |
| SearchOverlay | `src/components/GlobalSearch/SearchOverlay.tsx` | Search preview overlay (Stage 1 result preview) |
| MiniPlayer | `src/components/AppShell/MiniPlayer.tsx` | Bottom playback controls (Height 73px), using industry-leading capsule design: external cover art, drag-and-drop progress bar, dynamic volume level icon |
| FullPlayer | `src/components/AppShell/FullPlayer.tsx` | Full-screen immersive reading mode |

### Immersion Mode

- **State Management**: `src/store/immersionStore.ts` (Zustand)
- **Entry Method**: Click MiniPlayer area or Expand button
- **Exit Method**: Click Minimize button in top right of FullPlayer
- **Behavior**:
  - On Entry: Hide Sidebar, display FullPlayer full screen
  - On Exit: Restore normal layout
  - Uninterrupted Playback: `<audio>` element persists in `GlobalAudioController` (always mounted in `__root.tsx`)

### Performance Isolation: GlobalAudioController

To prevent the entire application from re-rendering on every audio tick (timeupdate), all audio element handling is isolated in `GlobalAudioController.tsx`:

| Component | File | Responsibility |
|------|------|------|
| GlobalAudioController | `src/components/AppShell/GlobalAudioController.tsx` | Handles `<audio>` element lifecycle, event listeners (timeupdate, play/pause, seek), volume/rate sync. Uses atomic Zustand selectors and `getState()` for actions. |

This ensures `RootLayout` remains effectively static unless the route changes, while only `GlobalAudioController` and any progress-bar components re-render during playback.

---

## 3. Routing (TanStack Router + File-Based Routing)

Uses TanStack Router for routing, with the route tree automatically generated by the Vite plugin.

### Route Structure

| Path | File | Description |
|------|------|------|
| `/` | `src/routes/index.tsx` | Main Player Page (Subtitle Reading) |
| `/search` | `src/routes/search.tsx` | Global Search Results Page (Accepts `?q=` param) |
| `/explore` | `src/routes/explore.tsx` | Discover Podcasts (Search) |
| `/podcast/:id` | `src/routes/podcast/$id.tsx` | Podcast Show Page (Episode List) |
| `/podcast/:id/episode/:episodeId` | `src/routes/podcast/$id/episode/$episodeId.tsx` | Episode Detail Page |
| `/subscriptions` | `src/routes/subscriptions.tsx` | Subscriptions List |
| `/favorites` | `src/routes/favorites.tsx` | Favorite Episodes |
| `/history` | `src/routes/history.tsx` | Playback History |
| `/files` | `src/routes/files.tsx` | Files Page (Audio/Subtitle management, Folder support, Drag & Drop) |
| `/settings` | `src/routes/settings.tsx` | Settings Page |

### Page Navigation Conventions

- Pages do not provide "Back to Previous/Up" buttons; users navigate via Sidebar or browser native back button.

### Key Designs

- **Persistent Player**: `<audio>` element and playback state mount in `__root.tsx`, playback is not interrupted by route changes
- **Route Generation**: `src/routeTree.gen.ts` is automatically generated by Vite plugin
- **Route-level Lazy Loading**: `/explore`, `/search`, Podcast Detail/Episode/History/Favorites/Files pages use `lazyRouteComponent` to split chunks, reducing initial bundle size
- **Heavy Module Lazy Loading**: `TranscriptView` in Main Player and `FullPlayer` in Immersion Mode use `React.lazy` for deferred loading
- **Global Styles**: CSS imported in `main.tsx` entry, ensuring availability across all routes
- **Playback Control**: Progress bar drag via `onSeek` → `store.seekTo` → `store.pendingSeek` → `__root.tsx` audio element, avoiding direct DOM manipulation
- **Proper Redirects**: Enforce `throw redirect()` inside `beforeLoad` or `loader` hooks rather than render-time `useEffect` or `<Navigate />` components to prevent layout thrashing and ensures data readiness.

---

## 4. Architecture Hardening

### Code Splitting

- **Vendor Chunks**: `vite.config.ts` uses `manualChunks` to split large dependencies

### Error Isolation

| Boundary | Scope | Fallback UI |
|------|----------|---------|
| `RootErrorBoundary` | Entire App | Full screen error page + Refresh button |
| TranscriptView ErrorBoundary | Transcript View | Friendly error message + Copy diagnostic info button |

### Uninterrupted Playback

`<audio>` element mounted in `GlobalAudioController` (inside `__root.tsx`), route switching does not affect playback.

### Tab Synchronization (Singleton Playback)

- Use `BroadcastChannel('readio_sync')` with `senderId` and `timestamp`.
- Ignore events from the current tab and any event older than 2 seconds.
- Provide a `localStorage` event fallback when BroadcastChannel is unavailable.

### Persistence & Restoration (Player Lifecycle)

The system uses a robust, store-driven lifecycle for maintaining playback progress and state:

- **State Machine**: `playerStore` maintains an `initializationStatus` (`idle | restoring | ready | failed`) to prevent race conditions during boot.
- **Single Source of Truth**: All persistence operations are centralized in `playerStore.ts`. Hooks like `useSession` and `useFileHandler` delegate to store actions rather than writing to DB directly.
- **Throttled Persistence**: Progress updates are throttled (default 5s) to reduce IndexedDB write pressure. A `saveProgressNow` action ensures data is saved immediately on unmount or critical events.
- **Atomic Restoration**: The `restoreSession` action encapsulates the entire logic of fetching the last session, restoring files/URLs, and updating state in a single atomic operation.
- **Validation Layers**: File validation is decoupled from ingestion. The `lite` app performs MIME/extension checks, while deep content validation is deferred to backend/native layers (see Decision D046).
- **Async Task Hygiene**: All async tasks are gated against stale updates using `requestId` or `AbortSignal`. Timers and `requestAnimationFrame` calls are explicitly tracked and cancelled on unmount to prevent memory leaks and state updates on unmounted components.
- **Async Sequence Gating**: Critical flows (e.g., session creation, dictionary lookup) use ref-based guards to prevent parallel re-entrancy of the same async operation.


---

## 4a. State Management Best Practices (Zustand)

### Atomic Selectors (Critical for Performance)

**Always use atomic selectors** to subscribe to individual store fields. Never destructure the entire store.

```tsx
// ❌ ANTI-PATTERN: Subscribes to ALL store changes
const { field1, field2, field3, progress } = usePlayerStore()

// ✅ BEST PRACTICE: Subscribe to individual fields
const field1 = usePlayerStore((s) => s.field1)
const field2 = usePlayerStore((s) => s.field2)
const field3 = usePlayerStore((s) => s.field3)
const progress = usePlayerStore((s) => s.progress)
```

**Rationale**: 
- Destructuring `const { ... } = useStore()` subscribes to **every field in the store**
- Components will re-render on **any** store update, not just changes to destructured fields
- This causes severe performance issues with high-frequency fields like `progress` (updates multiple times per second)

**Critical for**:
- Components rendering high-frequency fields (`progress`, `currentIndex`)
- Components with expensive rendering (images, complex layouts, gestures, animations)
- List components or components rendering media assets

### Example: Before vs After

**Before (Performance Issue)**:
```tsx
export function MiniPlayer() {
  const { progress, coverArtUrl, isPlaying } = usePlayerStore()
  // ❌ Component re-renders every time ANY store field changes
  // ❌ Causes image flickering when progress updates
}
```

**After (Optimized)**:
```tsx
export function MiniPlayer() {
  const progress = usePlayerStore((s) => s.progress)
  const coverArtUrl = usePlayerStore((s) => s.coverArtUrl)
  const isPlaying = usePlayerStore((s) => s.isPlaying)
  // ✅ Component only re-renders when individual fields change
  // ✅ No flickering, minimal re-renders
}
```

### Store Access Patterns

**Read-Only Access**:
```tsx
// For reading state in async functions or event handlers
const currentProgress = usePlayerStore.getState().progress
```

**Subscribe to Changes**:
```tsx
// For reactive UI updates
const progress = usePlayerStore((s) => s.progress)
```

**Actions (Functions)**:
```tsx
// Actions don't change, safe to extract once
const seekTo = usePlayerStore((s) => s.seekTo)
const togglePlayPause = usePlayerStore((s) => s.togglePlayPause)
```

### Performance Verification

After refactoring store subscriptions:
1. Use React DevTools Profiler to measure render counts
2. Expected: ~5-10 renders during 10s of playback (down from 100+)
3. Verify no visual flickering in images/artwork
4. Confirm all functionality works correctly

---

## Planned (Pending Execution)

- **Local Error Logger**: Downloadable diagnostics logs (Instruction 047).
- **DB Access Guard**: Prevent direct DB imports from UI (Instruction 057).
- **Atomic Write Safeguards**: Boot-time repair and transactional writes (Instruction 067).

---

## 5. Technology Stack

| Category | Tech |
|------|------|
| Framework | React 19 + TypeScript + Vite |
| Routing | TanStack Router (file-based) |
| State | Zustand |
| Persistence | Dexie (IndexedDB) |
| Network Cache | TanStack Query |
| Overlay/Tooltip | Radix UI |
| Toast | Sonner |
| Styling | Tailwind CSS + shadcn/ui |
| Testing | Vitest + Playwright |
| i18n | react-i18next (useTranslation) |
