---
title: 集成陷阱
---

# UI 集成陷阱与检查清单

本文档记录了将 `readio-ui-standard-demo` 原型集成到主项目时遇到的问题，由于为未来的迭代提供检查清单。

---

## 问题总结

### 问题 1: Virtuoso 虚拟列表高度计算失败

**症状**: 上传文件后，播放器页面完全空白，字幕不出现。

**根本原因**: 
`react-virtuoso` 需要明确的容器高度才能正确渲染虚拟列表。在集成过程中，我将 `Virtuoso` 组件包装在一个带 padding 的 `div` 中：

```tsx
// ❌ 不正确
<div className="max-w-3xl mx-auto px-6 py-20">
    <Virtuoso style={{ height: '100%' }} ... />
</div>
```

这个父 `div` 没有明确的高度，导致 `Virtuoso` 的 `height: 100%` 计算为 0，导致没有项目被渲染。

**Demo 为什么可以工作**: 
Demo 没有将 Virtuoso 包装在额外的 div 中；样式直接应用在 `itemContent` 内部。

**解决方案**:
```tsx
// ✅ 正确
<Virtuoso
    style={{ height: '100%' }}
    itemContent={(index, subtitle) => (
        <div className="max-w-3xl mx-auto px-6">
            <SubtitleLine ... />
        </div>
    )}
    components={{
        Header: () => <div className="h-20" />,
        Footer: () => <div className="h-[50vh]" />,
    }}
/>
```

---

### 问题 2: `useEffect` 依赖数组不完整导致事件监听器未绑定

**症状**: 播放音频时，进度条和时间显示一直卡在 `0:00`，字幕高亮不跟随播放头。

**根本原因**:
在 `__root.tsx` 中，音频事件监听器的 `useEffect` 依赖数组未包含 `audioUrl`：

```tsx
// ❌ 不正确
useEffect(() => {
    const audio = audioRef.current;
    if (!audio) return;  // 在首次挂载时，audio 为 null，所以提前返回
    
    audio.addEventListener('timeupdate', onTimeUpdate);
    // ...
}, [setProgress, setDuration]);  // 缺少 audioUrl
```

在第一次组件挂载时，`audioUrl` 为空，`<audio>` 元素尚未创建，`audioRef.current` 为 `null`。
由于 `setProgress` 和 `setDuration` 是稳定的函数引用，效果不会重新运行。
当用户上传文件且 `audioUrl` 更改时，`<audio>` 元素被创建，但 **监听器从未被添加**。

**Demo 为什么可以工作**:
Demo 使用 Context Provider 模式，其中音频元素在 Provider 初始化时创建，避免了“延迟创建”问题。

**解决方案**:
```tsx
// ✅ 正确
useEffect(() => {
    const audio = audioRef.current;
    if (!audio) return;
    
    audio.addEventListener('timeupdate', onTimeUpdate);
    // ...
}, [audioUrl, setProgress, setDuration]);  // 添加了 audioUrl
```

---

## 迭代检查清单

在执行 UI 集成或重构时，请检查以下内容：

### 虚拟列表 (react-virtuoso)

- [ ] Virtuoso 的 **直接父容器** 必须具有明确的高度 (`height: 100%` 或固定像素)。
- [ ] 不要在 Virtuoso 外部添加具有垂直 padding/margin 的容器。
- [ ] 使用 `components.Header` 和 `components.Footer` 为列表添加顶部/底部间距。
- [ ] 在测试期间，检查 DOM 中是否存在 `data-index` 属性。

### useEffect 依赖数组

- [ ] 当 effect 依赖于 ref 引用的元素时，考虑该元素是否可能仅在稍后的渲染中创建。
- [ ] 如果 ref 指向条件渲染的元素 (例如 `{condition && <element ref={ref} />}`)，条件变量必须在依赖数组中。
- [ ] 使用 Biome 的 `useExhaustiveDependencies` 规则，但要理解其警告。

### 音频播放器

- [ ] 音频元素的事件监听器必须仅在元素实际存在后绑定。
- [ ] 测试播放并验证：时间显示更新，进度条移动，字幕跟随。
- [ ] 使用浏览器控制台验证 `document.querySelector('audio').currentTime` 是否正在更改。

### 状态同步

- [ ] 确保 Store 状态更改正确触发 UI 更新。
- [ ] 当组件依赖于多个 Store 切片时，验证所有切片都已正确订阅。
- [ ] 测试完整的用户流程，而不仅仅是单个组件。

---

### 交互与焦点管理

- [ ] **Portal 事件冒泡**: 是否在 Dropdown / Popover Content 中明确停止了 `mousedown` 和 `onClick` 事件？(防止干扰父 Card 事件)。
- [ ] **非模态模式**: 涉及内联编辑 (例如，重命名) 的菜单是否设置了 `modal={false}`？(防止焦点窃取)。
- [ ] **声明式聚焦**: 是否优先使用 `autoFocus` 而不是 `setTimeout` 进行聚焦？
- [ ] **事件桥接**: 在复杂组件 (带有 MouseDown/Up/Click) 中，是否使用 Ref 标志来防止“双重触发”或逻辑竞争？

---

## 调试技巧

### 检查 Virtuoso 是否正在渲染

```javascript
// 在浏览器控制台中执行
document.querySelectorAll('[data-index]').length
// 如果虚拟列表未渲染任何项目，则返回 0
```

### 检查音频事件是否已绑定

```javascript
// 检查音频元素状态
const audio = document.querySelector('audio');
console.log({
    currentTime: audio?.currentTime,
    paused: audio?.paused,
    duration: audio?.duration
});

// 手动触发 timeupdate 进行测试
audio?.dispatchEvent(new Event('timeupdate'));
```

### 检查 Store 状态

由于 Zustand store 未暴露在 `window` 上，请在组件中添加临时日志：
```tsx
const progress = usePlayerStore(state => state.progress);
console.log('Current progress:', progress);
```

---

## 架构差异总结

| 方面 | Demo 架构 | 主项目架构 | 潜在问题 |
|---|---|---|---|
| 音频元素 | 在 Context Provider 中创建 | 在 `__root.tsx` 中条件渲染 | 需要处理延迟元素创建 |
| 路由 | 简单状态切换 | TanStack Router | 路由更改期间的状态持久化 |
| 字幕解析 | 内置模拟数据 | Dexie + 文件上传 | 异步加载时序 |
| 虚拟列表 | 无额外包装器 | 可能会添加样式容器 | 高度计算失败 |
