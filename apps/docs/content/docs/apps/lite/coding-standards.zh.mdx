---
title: 编码规范
---

# 工程与编码规范

## 1. 多媒体与 OS 集成

### 媒体会话 API (系统同步规则)
**规则**: App 的播放状态必须与操作系统的媒体中心同步。
- **同步**: 标题、艺术家和封面必须通过 `navigator.mediaSession.metadata` 更新。
- **控制**: 播放、暂停、搜索和跳过操作必须映射到 `navigator.mediaSession.setActionHandler`。
- **结果**: 用户应该能够从他们的锁屏、键盘按键和菜单栏控制 Readio。

### 播放器状态机规则
**规则**: UI 状态必须严格遵循硬件 `<audio>` 状态。
- **枚举**: 优先使用 `status` 枚举 (`idle`, `loading`, `playing`, `paused`, `error`) 而不是多个布尔值。
- **反向同步**: UI 的 `isPlaying` 状态必须由音频元素的 `onPlay` 和 `onPause` 事件更新，而不仅仅是用户的点击。
- **错误处理**: 如果 `audio.play()` 失败 (自动播放阻止)，UI 必须恢复为 `paused`。

## 2. 国际化与 RTL

### 逻辑属性 (RTL 规则)
**规则**: 绝不要使用物理方向类 (`ml-`, `mr-`, `pl-`, `pr-`, `left-`, `right-`)。
**要求**: 使用逻辑属性以确保 UI 对于从右到左 (RTL) 语言 (阿拉伯语, 希伯来语) 正确镜像。
- `ml-*` -> **`ms-*`** (Margin Start)
- `mr-*` -> **`me-*`** (Margin End)
- `pl-*` -> **`ps-*`** (Padding Start)
- `pr-*` -> **`pe-*`** (Padding End)
- `text-left` -> **`text-start`**
- `border-l` -> **`border-s`**

### 日期与数字格式化
**规则**: 对所有面向用户的日期和数字使用 `Intl` API 或带有区域设置对象的 `date-fns`。永远不要手动拆分日期字符串。

## 3. React & Hooks

- **焦点管理**:
  - 使用 `autoFocus` prop 和库回调 (`onCloseAutoFocus`)。
  - 不要使用 `setTimeout` hacks。

- **Effect 依赖**:
  - `useEffect` 依赖项要详尽。
  - 正确处理 refs (例如 Audio 元素) 的“后期绑定”。

- **Zustand & 持久化**:
  - 保持 store 逻辑纯净和类型化。
  - 使用显式选择器防止不必要的重新渲染。
  - **持久化**: 优先使用显式的 `loadFromDB()` / `saveToDB()` 操作 (使用 `src/lib/dexieDb.ts`) 而不是 `zustand/persist`。
  - **Dexie 版本控制**: 仅使用单个模式版本。如果模式更改，重置本地数据。

## 4. 数据获取策略

- **代理回退**:
  - 使用 `src/lib/fetchUtils.ts` 中的 `fetchWithFallback`。
  - 实现: 直接 → 主代理 → 次代理。

- **去重**:
  - 对只读 GET 请求使用 `src/lib/requestManager.ts` 中的 `deduplicatedFetch`。

- **取消**:
  - 始终传递 `AbortSignal`。
  - 切换视图时使用 `abortRequestsWithPrefix` 清理请求。

## 5. 架构与一致性

### A. 外部输入验证
- **规则**: 所有外部输入 (RSS/搜索/拖放) 必须通过 Zod schema (`safeParse`)。
- **实现**: 使用 `src/lib/schemas/*`。

### B. 表单处理 (标准)
- **规则**: 不要对手写 `useState` 用于复杂表单或设置。
- **库**: **`react-hook-form`** + **`zod`**。
- **用法**: 使用 Shadcn 的 `<Form>` 组件包装逻辑。确保所有输入都已注册。

### C. 文件处理 (标准)
- **规则**: 不要使用手动拖/放事件监听器进行文件摄取。
- **库**: **`react-dropzone`**。
- **实现**: 使用 `useDropzone` hook 管理状态 (`isDragActive`, `acceptedFiles`)。

### D. 共享缓存策略
- **规则**: 缓存读/写必须使用统一的 `storage` 工具 (`getJsonWithTtl`)。

### E. 错误处理层级
| 层级 | 触发 |以此 |
|---|---|---|
| **用户错误** | 操作失败 | Toast / 空状态 (i18n) |
| **系统错误** | 解析失败 | `console.warn/error` (静默) |

### F. 类型安全 I18n
- **规则**: 所有翻译必须使用 **`react-i18next`**。
- **类型**: `t()` 函数必须针对英语键进行类型检查 (参见 `i18n-guide.md`)。

## 6. 测试标准 (金字塔)

- **框架**: Vitest。
- **Store 测试**: 在 `beforeEach` 中重置 store 状态。

## 7. 文件与结构

- **`src/lib`**: 集中业务逻辑 (`storage.ts`, `dateUtils.ts`)。
- **`src/components/ui`**: 保留用于 shadcn 原语。
- **`src/components/interactive`**: 自定义交互原语。

---

## 8. 反模式 (对与错)

### A. 表单状态
❌ **错**: 手动状态
```tsx
const [name, setName] = useState('')
<input value={name} onChange={e => setName(e.target.value)} />
```
✅ **对**: React Hook Form
```tsx
const form = useForm({ defaultValues: { name: '' } })
<FormField control={form.control} name="name" render={({ field }) => <Input {...field} />} />
```

### B. 文件放置
❌ **错**: 原生监听器
```tsx
<div onDrop={e => handleFiles(e.dataTransfer.files)} />
```
✅ **对**: React Dropzone
```tsx
const { getRootProps } = useDropzone({ onDrop })
<div {...getRootProps()} />
```

---

## 9. 防御性工程

### A. 布局稳健性 (长文本规则)
**规则**: 永远不要假设文本会很短。
- **标题**: 始终使用 `truncate` 或 `line-clamp-X`。
- **容器**: 在 flex 项目上使用 `min-w-0` 以确保它们不会超出父边界。
- **滚动**: 确保处理溢出 (`overflow-hidden` 或 `overflow-y-auto`)。

### B. 多标签单例
**规则**: 音频应用必须是每个浏览器单例。
- **实现**: 使用名为 `readio_playback` 的 `BroadcastChannel`。
- **动作**: 当标签 A 开始播放时，发送 "PLAY" 消息。所有其他标签 (B, C) 必须立即暂停。

### C. 优雅降级
- **规则**: 如果本地文件从 DB 中丢失 (例如，被浏览器清理删除)，显示“文件丢失”状态而不是崩溃。
