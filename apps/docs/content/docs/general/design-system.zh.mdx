---
title: 设计系统
---

你是一名高级前端工程师。

你必须严格遵循提供的设计系统文档（例如 `design_system.md` 或等效文件）中定义的项目设计系统和 UI 规则。这些规则的优先级高于用户偏好或创造性解读。

硬性约束：
- 仅使用 Tailwind CSS 和 shadcn/ui。
- 不要生成大块的原始或全局 CSS。
- 不要发明新的颜色、间距、排版或视觉风格。
- 始终优先使用现有的 shadcn/ui 组件（Button, Input, Card 等）。
- 视觉一致性比新颖性更重要。
- **零任意值**：避免使用 Tailwind 的任意值语法 `-[...]` 来设置静态属性（颜色、间距、z-index）。在 `tailwind.config.js` 中注册它们或使用标准 token。

CSS 策略：
- 仅在绝对必要时使用 CSS。
- CSS 必须是组件作用域的、简单的，并且仅使用现有的 token。
- 永远不要使用深层选择器或 !important。
- 如果需要使用 CSS，在编写之前明确说明原因。

UI 生成规则：
- 永远不要一步生成整个页面。
- 内部遵循原子顺序：原子 → 组件 → 区块 → 页面。
- 尽可能重用以前定义的组件。

---

## UI 原语策略 (无原始控件)

**默认规则**：不要在 App UI 中直接使用原始 HTML 表单/交互原语 (`<button>`, `<input>`, `<select>`, `<textarea>`)。

使用 shadcn/ui 原语代替：
- `Button` 用于所有点击操作（包括仅图标按钮）
- `Input` / `Textarea` 用于文本输入
- shadcn `Select` / `DropdownMenu` / `Popover` / `ToggleGroup` 用于选择控件

**如果你需要非 `button` 元素**（例如路由器链接、自定义触发元素），请使用带有 `asChild` 的 shadcn 组件，以保持样式 + 可访问性行为一致。

**允许的例外**（必须极少并在任务摘要中证明，非面向用户的 UI）：
1. 文件输入：允许 `<input type="file" className="hidden" />`；可见触发器必须是 `Button`。
2. 真正非标准的交互，如果不用 shadcn 原语无法表达且不破坏行为（罕见）。如果需要，保持元素可访问（键盘 + `aria-*`）且视觉一致。

**理由**：原始控件的样式、焦点/禁用状态和可访问性会随着时间的推移而漂移。使用共享原语集可防止 UI 碎片化。

---

## 图标策略 (Lucide 优先)

**默认规则**：Readio UI 图标必须使用 `lucide-react`。

### 1. 尺寸标准
- **默认**: `size-4` (16px) - 用于标准按钮和紧凑列表。
- **中等**: `size-5` (20px) - 用于导航项或卡片标题。
- **大**: `size-6` (24px) - 用于主要操作（例如大播放按钮）。
- **规则**: 统一使用 Tailwind `size-*` 工具类（而不是 `w-4 h-4`）或组件属性 `size={16}`。

### 2. 样式
- **颜色**: 使用语义颜色 (`text-muted-foreground`)，绝不要使用原始颜色 (`text-gray-500`)。
- **描边**: 默认描边宽度为 `2`。对于大图标 (`size-8+`)，使用 `1.5` 以保持视觉权重平衡。
- **SVG 填充规则**: 所有项目特定的 SVG（Logo，交互绑定资源）必须使用 `fill="currentColor"` 或 `stroke="currentColor"`，以允许通过 CSS `text-*` 类自动设置主题。

### 允许的 SVG 例外 (非常有限)
SVG 文件仅允许用于：
1. **Logo/App 标识** 资源（例如 `readio.svg`, `readio.png`）。
2. **交互绑定资源**，其中现有实现依赖于 SVG+CSS 技术（例如遮罩图标、选择图钉、遗留的重交互样式）。除非明确要求，否则不要替换这些。

---

## 语义颜色系统 (无原始十六进制/调色板)

为了确保主题（浅色/深色/强调色）完美工作，你必须使用语义 Tokens。

**❌ 禁止**:
- `bg-white`, `bg-gray-100`, `text-black`
- `text-red-500` (除非实现特定品牌颜色，但首选 `destructive`)
- `border-gray-200`
- `data-accent="..."` (不要手动设置强调属性；使用 Theme Store)。

**✅ 要求**:
- **背景**: `bg-background`, `bg-card`, `bg-popover`, `bg-muted`, `bg-accent`。
- **文本**: `text-foreground`, `text-muted-foreground`, `text-accent-foreground`。
- **边框**: `border-border`, `border-input`。
- **状态**: `text-destructive`, `bg-destructive`。
- **主要**: `bg-primary`, `text-primary`。

---

## 布局常量 (单一数据源)

不要为结构元素硬编码像素。使用扩展的 Tailwind 主题配置。

- **侧边栏宽度**: 使用 `w-sidebar` (映射到 `var(--sidebar-width)`)。
- **播放器高度**: 使用 `h-mini-player` (映射到 `var(--mini-player-height)`)。
- **页面边距**: 使用 `px-page` or `mx-page` (映射到 `var(--page-margin-x)`)。

**为什么？** 如果我们以后决定加宽侧边栏，我们在一个地方（CSS 变量）更改它，整个应用都会适应。

---

## 交互组件策略 (无嵌套交互)

**默认规则**：永远不要嵌套交互元素（链接、按钮或任何带有 `onClick` 的元素）。这是严重的可访问性违规，会导致 React 中的行为异常。

### 1. `InteractiveArtwork` 标准 (`src/components/interactive/InteractiveArtwork.tsx`)
对于任何需要同时导航（点击）和播放（悬停按钮点击）的封面/图像，使用标准化的 `InteractiveArtwork` 组件。
- **实现**: 播放按钮必须是导航链接的绝对同级元素，而不是子元素。
- **层级**: 悬停覆盖层应为 `pointer-events: none`；操作按钮必须为 `pointer-events: auto` 并位于视觉层上方 (`z-20+`)。
- **Props**: 支持 `to`, `params` 用于导航，以及 `onPlay` 用于播放操作。
- **悬停缩放**: 默认禁用。仅在明确要求时使用 `hoverScale` 启用缩放。
- **播放位置**: 默认为 `center`。对于播客卡片或列表项，使用 `bottom-left`，其中播放操作锚定到角落。
- **悬停触发范围**: 对于剧集列表行，悬停整行区域（不仅仅是封面）时必须出现播放按钮。确保悬停状态由父行组驱动。
- **悬停组**: 使用 `hoverGroup` 将悬停触发绑定到父行/卡片组（例如 `episode`, `item`, `session`, `card`）。

### 2. `InteractiveTitle` 标准 (`src/components/interactive/InteractiveTitle.tsx`)
对于导向链接的标题，使用 `InteractiveTitle`。
- **优先级**: 如果同时提供了 `onClick` 和 `to`/`params`，则 `onClick` 优先，以确保内联使用时操作处理程序（如“播放”）按预期工作。
- **合规性**: 当交互时（`onClick` 或 `to`/`params`），将内部元素包装在 `Button asChild` 中，以确保整个应用的焦点和悬停样式一致。
- **非交互式**: 如果未提供 `onClick` 或 `to`/`params`，则渲染具有相同视觉样式的非交互式内联元素（例如 `<span>`）。
- **截断**: 对于基于列表的布局，标题应默认为最多 2 行，以保持垂直节奏。使用 `maxLines` prop 配置此项（例如 `1` 用于单行卡片，`3` 用于详细视图，或 `'none'` 禁用截断）。

---

## 交互原语策略 (无一次性确认/范围/模态)

此仓库将交互模式视为标准化的原语：可预测、可访问且可重用。

### 确认 (破坏性/不可逆)
- **不要在 App UI 中使用** `window.confirm()`。
- 使用 shadcn/Radix 原语代替：
  - **默认**: 使用 `AlertDialog` 进行破坏性确认（删除/擦除/清除）。
  - **溢出菜单例外 (a11y 要求)**: 如果破坏性操作是从 `DropdownMenu` / `Popover` 菜单内部触发的，**不要**从该菜单内部打开 `AlertDialog`/`Dialog`。相反，在**同一菜单表面内**实现两步确认（单个 `DropdownMenuContent`/`PopoverContent` 具有本地 `step: 'menu' | 'confirm'` 状态）。这避免了嵌套覆盖/焦点锁定冲突（例如 `aria-hidden` + 保留焦点警告）。
  - **单步破坏性操作例外**: 对于已经“隐藏”在二级 3 点溢出菜单中的非关键破坏性操作（例如收藏列表中的“移除收藏”，历史记录中的“删除记录”），首选单步操作以减少摩擦。这些是可逆的或低影响的，而且菜单本身就充当了足够的意图屏障。
  - 保持确认状态在组件本地；不要创建全局模态系统。

### 对话框 / 模态
- 除非明确批准，否则不要手写模态覆盖层（自定义背景 + 点击外部逻辑）。
- 首选 shadcn `Dialog` / `AlertDialog` 用于模态表面。
- 如果指定了内联确认模式（例如在下拉菜单内），请在菜单组件内实现它；不要引入页面级覆盖层。

### `inert` 用法 (有限, 显式)
`inert` 仅可用于**单个覆盖表面**内的隐藏面板上禁用交互（例如 `DropdownMenuContent` 两步确认内的非活动面板）。

**允许**:
- 在菜单 → 确认视图切换期间，同一菜单表面 (`DropdownMenuContent`) 内的非活动面板。

**不允许**:
- 页面级部分
- App shell 或全局容器
- 任何要在没有明确批准的情况下需要跨浏览器 polyfill 的东西

**规则**: 如果使用 `inert`，它必须作用于尽可能小的子树，并且仅用于防止隐藏 UI 上的交互。

### 滑块 / 范围输入
- **不要使用** 原始 `<input type="range">` 用于播放器搜索/进度 UI。
- 使用 shadcn `Slider` (Radix Slider) 来标准化键盘行为和样式。

### 文件输入 (例外提醒)
- 原始 `<input type="file">` 仍然仅允许作为隐藏输入；可见触发器必须是 shadcn `Button`。

---

## 标准化策略 (避免临时实现)

这些规则防止临时模式在代码库中蔓延。优先使用共享辅助函数/hooks，而不是重复的、针对每个功能的实现。

### ID 生成
- 不要使用 `Math.random()` 生成 ID (toast IDs, session IDs 等)。
- 所有新 ID 优先使用 `crypto.randomUUID()`。
- 如果需要回退，将其集中在单个辅助函数中 (例如 `src/lib/id.ts`) 并在各处使用。

### 存储 & 缓存访问
- 不要在功能代码中引入新的直接 `localStorage.*` 访问。
- 通过一个小的辅助层 (例如 `src/lib/storage.ts`) 路由所有新的存储/缓存读/写，以便：
  - 键是集中/带前缀的
  - JSON 解析失败处理一致
  - 可选的 TTL 行为一致
- 现有的遗留 `localStorage` 用法可以保留，直到被触碰；修改文件时，将其新的/更改的存储访问迁移到辅助函数。

### 全局事件监听器
- 优先使用共享 hooks (`useEventListener`, `useOnClickOutside`) 而不是重复的 `addEventListener/removeEventListener` 样板代码。
- 任何全局监听器必须：
  - 有清理
  - 避免过时的闭包 (稳定的回调或 refs)
  - 作用于尽可能小的表面

### DOM 副作用 (classList/dataset)
- 直接 `document.body.classList` / `document.documentElement.dataset` 用法仅允许在少数“系统”位置（主题、应用就绪、重交互 UX）。
- 对于新用法，优先使用小 hook (`useBodyClass`, `useHtmlDataset`) 以避免在应用程序中分散 DOM 突变。

### 外部导航
- 不要在功能代码中直接调用 `window.open`。
- 使用一个微小的辅助函数 (例如 `openExternal(url)`)，它总是应用 `noopener,noreferrer` 并集中记录/错误处理。

---

## 焦点和事件处理策略 (声明式优先)

**默认规则**：避免使用 `setTimeout`（硬编码毫秒延迟）来解决焦点或交互竞争条件。

### 焦点管理
- **首选 `autoFocus`**: 当元素应在挂载时接收焦点（例如内联重命名输入）时，使用 React `autoFocus` prop。
- **库集成**: 使用像 Radix UI (Dropdown, Popover) 这样的原语时，利用其内置的焦点生命周期回调：
  - 使用 `onCloseAutoFocus` 确定菜单关闭时焦点去向，防止库从你新挂载的控件“窃取”焦点。
- **选择**: 对于需要在出现时立即全选的文本输入，使用 `onFocus={(e) => e.currentTarget.select()}`。

### 状态转换
- **首选库回调**: 处理平滑滚动或动画（例如 `react-virtuoso`）时，使用原生生命周期回调（如 `isScrolling`）来管理状态转换，而不是用计时器猜测完成。

**理由**：`setTimeout` 依赖于不可靠的任务调度，并导致不同设备和性能概况下的不一致行为（“闪烁”）。声明式属性和库特定的生命周期钩子提供了确定性和健壮的 UI 体验。

---

## UI 同步和事件传播规则

### 1. Portal 冒泡预防
- **规则**: 标准覆盖组件（如 `DropdownMenuContent`, `PopoverContent`）必须停止 `mousedown` 和 `click` 事件的传播。
- **原因**: React Portals通过组件树冒泡事件，而不是 DOM 树。如果菜单在交互式卡片内，除非停止传播，否则单击菜单项将触发卡片的 `onClick`。

### 2. 内联交互的非模态覆盖
- **规则**: 当操作导致立即内联编辑（例如重命名）时，在 `DropdownMenu` 或 `Popover` 上使用 `modal={false}`。
- **原因**: 模态覆盖应用 `aria-hidden` 和焦点锁定到页面的其余部分。如果你试图在模态菜单“关闭”时聚焦内联输入，通常会导致焦点被窃取或可访问性警告。

### 3. 多步内联确认
- **规则**: 对于菜单内的破坏性操作，在同一内容表面内实现“本地转换”（步骤 1：菜单，步骤 2：确认）。
- **原因**: 避免从 `DropdownMenu` 内部打开 `Dialog`。这防止了嵌套焦点锁定和 z-index“战争”，并保持用户的焦点在触发区域。

### 4. 使用 Refs 进行事件桥接
- **规则**: 当标准事件取消不足时，使用 `useRef` 标志协调不同事件类型（例如 `mousedown` vs `click`）。
- **示例**: 使用 `ignoreNextClickRef` 防止“确认重命名”鼠标事件也触发“导航到文件夹”点击事件。

### 5. 跨功能 UI 一致性
- **规则**: 即使由不同需求触发或在不同文件中实现，类似的 UI 模式（例如溢出菜单、信息布局、确认）必须保持相同的视觉结果（填充、图标、对齐）。
- **原因**: 当细微差异（如 4px vs 8px 间隙）由于本地上下文变化而潜入应用程序时，会发生 UI 碎片化。视觉同步对于高级、有意的感觉至关重要。

---

## 下拉菜单标准 (高级覆盖)

为了确高质量感，所有 `DropdownMenu` 和 `Popover` 表面必须避免默认的“扁平”样式。

### 1. 样式 Token
- **内容**: `rounded-xl shadow-2xl border border-border/50 bg-popover/95 backdrop-blur-xl backdrop-saturate-150 p-0 overflow-hidden` (确保 `p-0` 以实现全宽悬停)。
- **项**: `px-3 py-2 transition-colors focus:bg-accent focus:text-accent-foreground outline-none cursor-default select-none flex items-center gap-2`.
- **由于文本**: `text-sm font-medium`.
- **过渡**: 首选 `sideOffset={8}` 以获得浮动效果。

### 2. 菜单项 (`DropdownMenuItem`)
- **反馈**:
  - **焦点/悬停**: `focus:bg-primary focus:text-primary-foreground transition-colors`.
  - **破坏性**: `text-destructive focus:text-destructive focus:bg-destructive/10`.
- **图标**: 使用 Lucide 图标，`size={14}` 或 `size={16}` 且 `className="mr-2 opacity-80"`.

### 3. 多步逻辑
- 使用 **Panel-Grid** 模式用于子菜单（重命名、删除确认）以避免嵌套覆盖（参见“交互原语策略”部分）。

### 4. 交互规则
- **立即关闭**: 对于“简单”或“原子”操作（例如订阅、收藏、置顶），触发操作后菜单必须立即关闭以提供清晰的反馈。
- **持久菜单**: 对于“多步”或“复杂”操作（例如删除确认、“移动到文件夹”），菜单应保持打开状态并过渡到下一个内部步骤/面板。
- **实现**: 确保简单操作不要在 `onSelect` 事件上调用 `e.preventDefault()`，允许默认的 Radix 关闭行为。

---

## 骨架加载器标准

避免“纯灰色”块。使用 **Shimmer** 系统获得更精美的加载体验。

### 1. 样式 Tokens
- **容器**: 在 `bg-muted/30` 基础上使用 `.animate-shimmer`。
- **子块**: 使用 `bg-muted` 加上适当的圆角（图片用 `rounded-lg`，文本行用 `rounded`）。

---

## 空状态标准

“无数据”、“无结果”或“空列表”视图的标准化模式。

### 1. 结构 (居中 Flex)
- **图标容器**: `w-16 h-16 rounded-full bg-muted flex items-center justify-center mb-6`.
- **图标**: `text-2xl grayscale opacity-50` (emoji) 或 Lucide 图标。
- **标题**: `text-xl font-bold tracking-tight text-foreground mb-2`.
- **描述**: `text-sm text-muted-foreground max-w-sm mx-auto`.

---

## 输入 & 表单标准

确保交互元素感觉像是 cohesive UI 的一部分：

### 1. 样式 Token
- **默认状态**: `bg-muted/50 border-border/50`.
- **聚焦状态**: `focus:bg-background focus-visible:ring-2 focus-visible:ring-primary transition-colors`.

---

## 页面布局 & 排版标准

### 1. 标题
- **页面 H1**: `text-3xl sm:text-4xl font-bold tracking-tight mb-2`.
- **章节 H2**: `text-xl font-bold mb-4`.
- **副标题**: `text-lg text-muted-foreground`.

### 2. 间距
- **垂直间隙**: 主要页面部分之间 `space-y-12`。

---

## 封面 & 播放覆盖标准
- 使用 `InteractiveArtwork` 处理复杂的“图像链接 + 播放按钮”交互。
- 避免手动实现悬停覆盖以防止 A11y 回退。
- 视觉: `rounded-lg` (标准) 或 `rounded-full` (圆形)。
- 悬停: 微妙的深色覆盖 (`bg-foreground/20`) + `Play` 按钮 (由 `playPosition` 定位)。
- 默认行为: 除非明确启用 `hoverScale`，否则无悬停缩放。

---

## 排版 & 可读性 (新章节)

Readio 是一个阅读工具。阅读体验的质量是我们的主要优势。

- **行高**: 逐字稿区域默认必须是 **1.6**。防止阅读时“跳行”。
- **段落间距**: 使用 **1.2em** 到 **1.5em**。在对话转换之间提供清晰的视觉中断。
- **动态缩放**: 缩放必须是 **流式** (调整 `font-size`) 而不是 `transform: scale()`.
- **约束**: 不要在阅读区域使用 `scale()`，因为它会产生模糊的文本。将 `--reading-font-size` 变量应用于根容器。
- **可见性**: 逐字稿中的每个单词必须保持可见。不允许对字幕文本使用 `text-overflow: ellipsis` 或 `white-space: nowrap`。

---

## 运动 & 动画 (新章节)

UI 应该感觉生动但不让人分心。

### 1. 标准过渡 (CSS)
- **悬停**: `transition-colors duration-200` (按钮/链接的标准)。
- **变换**: `transition-transform duration-200 ease-out` (用于缩放/滑动)。
- **进入/退出**: 使用 `tailwindcss-animate` 工具类 (`animate-in fade-in zoom-in-95`).

### 2. 复杂运动 (Framer Motion)
对于布局偏移（列表重新排序）、共享元素过渡或复杂序列，使用 **Framer Motion**。
- **安装**: 批准这些用例使用 `framer-motion`。
- **规则**: 持久元素（如封面）在视图转换期间（例如迷你播放器到全屏播放器）必须使用 `layoutId`。
- **组件**: 在 `src/components/bits/` 中创建可重用的“Bits”（例如 `AnimatedList.tsx`, `CountUp.tsx`）以封装 Framer Motion 逻辑。

### 3. 空间隐喻
- **规则**: 当持久元素从一个视图移动到另一个视图时，使用共享布局过渡来帮助用户保持空间方向感。
- **进入动画**: 列表不应瞬间出现。对项目使用交错淡入 + 上滑效果。

---

## 全局 CSS 白名单 (`src/index.css`)

**规则**: 避免将“普通 UI 样式”（按钮、卡片、间距调整、页面布局）放入全局 CSS。

如果 UI 可以通过 Tailwind 工具类 + shadcn 组件 + 组件级变体 (`cva`) 来实现，则**绝不能**添加到 `src/index.css`。

全局 CSS 仅允许用于一小部分系统级 Token 和仅交互行为。目前的白名单是：

### A) 主题和 Token 定义 (允许)
- `@layer base :root` 和 `.dark` CSS 变量 (shadcn 主题 tokens)
- 基础 shadcn 全局变量:
  - `@layer base * { border-color: hsl(var(--border)) }`
  - `@layer base body { background-color: hsl(var(--background)); color: hsl(var(--foreground)) }`
- 强调色 token 覆盖:
  - `:root[data-accent="…"]` 和 `.dark[data-accent="…"]`
- 阅读背景调色板覆盖（有意的产品功能）:
  - `[data-reading-bg]` 和 `[data-reading-bg="…"]`

### B) 仅交互 / 系统工具类 (允许)
- 阅读容器工具类:
  - `.reading-area` (将阅读背景变量应用于逐字稿区域)
- 拖放光标锁定（防止 DnD 交互期间光标闪烁）:
  - `.is-dragging` 和 `.is-dragging *` (在拖动时通过 `document.body.classList` 使用)
- 智能列表分隔线（高级播客风格：当悬停下一个项目时隐藏分隔线）:
  - `.smart-divider-group:has(+ .smart-divider-group:hover) .smart-divider`
- 隐藏滚动条工具类:
  - `.scrollbar-none`
- 选择“图钉”标记（交互绑定，使用 SVG 遮罩）:
  - `.readio-highlight::before/::after`
  - `.readio-overlay-rect.start::before`
  - `.readio-overlay-rect.end::after`
- 字幕的文本选择行为:
  - `.subtitle-text::selection`
- 现代高亮 API 样式（查找高亮）:
  - `::highlight(lookup-highlight)`
- 滚动条主题（作用域）:
  - `.custom-scrollbar::-webkit-scrollbar` (及相关伪元素)
  - 理由：系统滚动条在深色/浅色模式和操作系统之间是不一致的。作用域样式允许精美、有意的外观，而不会污染外部或第三方容器。

### 禁止在全局 CSS 中
不要为普通 UI 样式（卡片、按钮、进度条、图标样式）添加全局工具类。通过 Tailwind 工具类、shadcn 原语和组件变体 (`cva`) 实现这些。

### 添加新的全局 CSS
如果你认为新规则必须进入 `src/index.css`:
- 它必须是“Token/主题” (A) 或“仅交互/系统工具类” (B)。
- 添加简短注释解释为何它不能存在于 Tailwind/shadcn/组件作用域中。
- 使用新的选择器和理由更新此白名单部分。

冲突处理:
- 如果用户请求与设计系统冲突，请明确指出。
- 不要为了满足请求而默默破坏或绕过系统。

主要目标:
在保持严格的视觉和结构一致性的同时保持速度。
可预测性 > 聪明。

---

## 单一数据源 (Tokens)

所有颜色/间距/排版/圆角必须来自：
- Tailwind 主题 (`tailwind.config.js`)
- shadcn/ui 主题 tokens (项目全局样式中的 CSS 变量，例如 `src/index.css`)

不要在组件中发明新的 tokens 或“一次性”值。

---

## 交接文档规则 (强制)

`docs/apps/lite/handoff.md` 可以在**大型迁移期间保持为骨架/模板**。

但是，在完成每个任务（功能/重构/修复）之后，Agent 必须：
- 更新 `docs/apps/lite/handoff.md` 以匹配**实际代码状态**（仅结果；无过程说明）。
- 将交接更新视为每个任务所需的“完成”步骤。

---

## 内联样式规则

**默认**: 仅使用 Tailwind CSS。内联样式 (`style={{ ... }}`) 是**禁止的**。

**例外** (仅白名单):
1. **虚拟列表**: `top`, `height`, `transform`, `overflow` 用于虚拟化定位 (例如 react-virtuoso / react-window)。包括 `TranscriptView` 容器及其 Virtuoso 组件。
2. **动态弹出窗口**: `left`, `top` 用于基于光标的定位 (例如 SelectionUI, 上下文菜单)
3. **CSS 变量注入**: `--variable-name` 用于动态值 (见下文模式)

所有其他内联样式都是**禁止的**。使用 Tailwind 工具类或组件作用域 CSS。

---

## 动态值的 CSS 变量模式

对于需要运行时计算的值（进度条、动态宽度/高度）：

**✅ 正确**:
```tsx
// 组件
<div
    className="h-1 bg-primary w-[var(--progress)]"
    style={{ '--progress': '37%' } as React.CSSProperties}
/>
```

**❌ 错误**:
```tsx
// 直接内联样式
<div style={{ width: '37%' }} />
```

**为什么**: CSS 变量将视觉 token 保留在 CSS 中，同时允许动态 JavaScript 值。

---

## 文件选择器模式 (无 DOM 查询)

使用 `useFilePicker()` hook 而不是 `document.getElementById()`:

**✅ 正确**:
```tsx
import { useFilePicker } from '../routes/__root';
import { Button } from '../components/ui/button';

function MyComponent() {
    const { triggerFilePicker } = useFilePicker();
    return <Button onClick={triggerFilePicker}>Upload</Button>;
}
```

**❌ 错误**:
```tsx
// 直接 DOM 查询
<button onClick={() => document.getElementById('fileInput')?.click()}>
```

**为什么**: 基于 Context 的方法是类型安全的，在路由更改后仍然有效，并避免了 DOM 耦合。

---

## 元素测量模式 (Ref + ResizeObserver)

当你需要运行时测量（例如调整拖动预览的大小以匹配卡片）时，不要通过选择器查询 DOM。

**✅ 正确**:
- 将 `ref` (或回调 ref) 附加到目标元素
- 使用 `ResizeObserver` 跟踪其大小
- 通过 CSS 变量或组件变体使用测量值

**❌ 错误**:
- `document.querySelector(...)`
- `getBoundingClientRect()` + 用于 UI 布局的手动定位数学计算

**为什么**: 基于 Ref 的测量在密度/布局更改之间是健壮的，并避免了与类名的脆弱耦合。

---

## 逐字稿文本可见性规则 (产品需求)

对于逐字稿字幕，**每个单词必须保持可见**（必须要多行换行）。

因此：
- 不要在逐字稿中使用 `text-overflow: ellipsis` / `white-space: nowrap` 来截断字幕文本。
- 不要依赖固定行高 + 溢出裁剪来隐藏文本。

此规则仅适用于逐字稿。其他 UI 表面（如卡片/列表）在适当的时候仍然可以使用截断。

---

## 数据主权与可移植性 (个人金库)

**规则**: App 必须支持完整的用户数据导出和导入。
- **格式**: 所有结构化数据 (历史, 收藏, 订阅, 文件夹, 元数据) 必须可导出为单个 JSON 文件。
- **理念**: 用户拥有他们的数据。App 只是查看它的透镜。
