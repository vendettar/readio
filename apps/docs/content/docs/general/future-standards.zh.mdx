---
title: 未来标准化
---

# 未来标准化方向 (可维护性“正规化”积压工作)

本文档列出了将重复模式标准化为共享原语、辅助函数和 hooks 的高 ROI 重构。

这些项目不一定是立即需要的，但随着代码库的增长以及多个功能开始重复相同的交互和基础设施模式，它们是强有力的候选者。

项目范围的约束仍然适用：
- 仅 Tailwind + shadcn/ui
- 除了 `docs/design_system.md` 中批准的例外情况外，没有临时原始 HTML 控件
- 优先考虑共享原语而不是针对每个功能的实现

---

## 1) 确认对话框标准化

**问题**
- 确认往往是每个页面重复实现的，带有定制的状态 + 接线。
- 随着时间的推移，文案、可访问性和关闭/退出行为会发生分歧。

**方向**
- 引入可重用的基于 shadcn/Radix 的确认原语：
  - `ConfirmAlertDialog` 组件 (shadcn `AlertDialog` 的包装器)
  - 可选的本地 hook: `useConfirmDialog()` 用于页面级状态

**范围**
- 破坏性确认 (删除/擦除/清除)
- 必须保持本地化 (除非明确需要，否则避免全局模态系统)

---

## 2) 溢出菜单标准化 (卡片菜单)

**问题**
- 文件夹/轨道和未来的卡片菜单重复：
  - 触发按钮样式
  - 菜单放置默认值 (side/align/offset)
  - 关闭/切换语义
  - stopPropagation 模式

**方向**
- 在 shadcn `DropdownMenu` 上添加共享 `OverflowMenu` 包装器：
  - 标准触发器 (幽灵图标按钮)
  - 标准内容默认值 (`side="bottom"`, `align="end"`, `sideOffset`)
  - 保持菜单项归每个功能所有

**范围**
- 现在的文件夹/轨道菜单；未来实体的可重用

---

## 3) 密度系统标准化 (变体存在于组件中)

**问题**
- 视图偏好（例如紧凑/舒适）可能导致路由/页面中的类分支。
- 这增加了页面复杂性，并使未来的控件（排序/分组/筛选）更难清晰地添加。

**方向**
- 通过变体 (`cva`/`cn`) 将密度样式保留在表示组件内部：
  - `TrackCard` (及其字幕行)
- 路由/页面仅拥有：
  - 读取/持久化密度
  - 传递单个 `density` prop (或单个 `data-density` 属性)

---

## 4) 存储 & 缓存标准化 (Keys, TTL, 命名空间清除)

**问题**
- 直接使用 `localStorage` 往往会扩散：
  - 不一致的键命名/前缀
  - 不一致的 JSON 解析失败行为
  - 不一致的 TTL 语义和清理

**方向**
- 在 `src/lib/storage.ts` 中集中存储辅助函数：
  - 键构建器 / 前缀约定
  - 安全的 JSON 读/写工具
  - 需要时的 TTL 辅助函数
  - 命名空间清除工具 (对开发工具和故障排除有用)

**注意**
- 首次发布策略允许重置；不要过度设计迁移/兼容层。

---

## 5) ID 生成标准化 (语义 ID)

**问题**
- ID 最终是临时创建的（格式漂移；意外的 `Math.random()` 用法）。

**方向**
- 在 `src/lib/id.ts` 中集中 ID 生成：
  - `createId()` (在可用的地方使用 UUID)
  - 语义辅助函数: `createToastId()`, `createSessionId()` 等
  - 避免在 `id.ts` 回退路径之外直接使用 `Math.random()`

---

## 6) 设置页面分解 (Hooks 拥有逻辑, 路由拥有布局)

**问题**
- 设置页面自然会发展成“包罗万象”的页面，并成为维护热点。
- 混合数据获取、突变和 UI 组合增加了认知负担。

**方向**
- 将逻辑提取到 hooks：
  - `useSettingsData()` (读取 + 重新加载)
  - `useStorageMaintenance()` (突变: 删除/清除/擦除)
- 保持 `src/routes/settings.tsx` 仅用于编排：
  - 组合
  - 连接到确认对话框原语

---

## 何时优先考虑这些

当出现以下情况时优先考虑这些重构：
- 相同的交互模式出现在 2 个以上的地方
- 你看到重复的样板代码在每个功能中增加
- 一个新功能需要复制现有代码并进行“小调整”

推迟当：
- 该更改将是一个具有低即时产品价值的大型横切重构
- 行为仍在快速演变，API 尚未稳定

---

## 当前关注点补充 (文件 / 探索迭代)

如果近期路线图主要是打磨 **Files** 和 **Explore**，在添加新库/框架之前优先考虑这两个标准化：

### A) 内联编辑模式 (重命名 & 小编辑)

**为什么现在**
- Files 已经有（或很快会有）多个内联编辑（集合重命名，轨道重命名，字幕重命名）。
- 如果没有共享模式，键盘行为和验证很快就会漂移。

**方向**
- 为内联编辑引入一个小型的可重用组件或 hook：
  - 组件选项: `InlineRenameInput` (基于 shadcn `Input` 构建)
  - Hook 选项: `useInlineEdit()` (管理编辑/值/提交/取消)
- 标准化规则：
  - `Enter` 确认，`Escape` 取消
  - 验证非空 (trim)
  - 模糊行为一致 (取消或提交；选一个)
  - 可访问标签 (相关的 `aria-label`, `aria-invalid`)

### B) Explore 数据加载约定 (TanStack Query)

**为什么现在**
- Explore 将演变为列表 + 过滤器 + 分页 / 加载更多。
- 一致的查询键和 UI 状态 (加载/空/错误) 防止碎片化。

**方向**
- 标准化 `queryKey` 命名：
  - `['explore', featureName, normalizedParams...]`
- 标准化 UI 状态：
  - 共享空状态、错误状态和骨架/加载模式 (小型可重用组件)
- 并发/取消：
  - 依赖 fetch 函数中的 Query `signal`
  - 除非严格必要，否则避免每个功能的临时 AbortController 用法

---

## 视图密度范围 (项目决策)

**视图密度**设置 (`comfortable` / `compact`) 适用于整个 **Files** 页面：
- 文件/轨道卡片 (和字幕行)
- 集合/文件夹卡片 (和文件夹网格)

这是一个有意的 UX 选择：紧凑模式增加了整个 Files 表面的信息密度，而不仅仅是轨道列表。
